# Ch2. Man-month mythical

### Optimism

소프트웨어 프로젝트가 실패하는 가장 흔한 이유 ⇒ 일정 때문에 실패하는 경우가 대부분이다

왜일까?

- 견적을 측정하는 스킬이 아직 부족하기 때문에
- 노동력과 작업 진행의 관계를 혼동하고 있기 때문에
    - 인력과 작업은 상화 교환 가능한 관계가 아니다
- 진행 상황을 제대로 감독하지 못한다

프로그래머들은 낙과주의적 성향이 강하다

→ 프로그래밍 일정 계획에 모든 것이 다 잘 될 것이라고 가정하게 된다

→ (why?)컴퓨터 프로그래밍은 예술이나 다른 분야의 창작과 달리 물리적인 구현과 구현체가 필요하지 않다

→ 그래서 결국 프로그래머들은 쉽게 낙관주의적 성향에 빠진다

<aside>
💡 **따라서 모든 것이 잘 진행될 것이라는 가정은 단일 임무에서 확률에 기대게 하는 영향을 미치게 되고 이는 대형 프로젝트를 마치게 하는데 큰 악영향을 미친다**

</aside>

![Untitled](Ch2%20Man-month%20mythical%2091f045b3f18e4a6098de7a371cb0eb29/Untitled.png)

- men month는 커뮤니케이션이 필요하지 않은 작업자에 한해서만 가능하다
- 특히 분할이 불가능한 업무일 경우 노동력을 더 투입하더라도 일정을 단축하는 효과는 전혀 없다
- 소통 때문에 추가되는 노력은 원래 임무를 분할한 효과를 상쇄한다 (4번째 그래프)

### System Test

- 프로그래밍 일정 계획이 가장 부정확하게 잡히는 이유이다
- 디버깅과 시스템 테스트에서 발생하는 오류의 수에 따라 시간이 달라지고 이는 예상하기 어렵다

업무의 일정을 잡을 때는 아래와 같이 계획하고 시간을 분할하는 것이 성공적일 확률이 높다

1/3 계획

1/6 코딩작업

**1/4 컴포넌트 테스트, 초기 시스템 테스트**

**1/4 시스템 테스트**

디버깅에 절반 이상을 할애하게 되는데, 이렇게 계획하지 않은 대부분의 프로젝트들도 결국에는 저 계획과 같이 시간을 쓰게 된다

만약, 테스트에 충분한 시간을 할애하지 못한다면, 전체 일정 마지막에 가서 기간을 못맞추고 늦게 완성하게 된다

이에 대한 해결책은 다음과 같다

- 버그 발생 수치, 견적 규칙, 생산성 수치를 개발하고 발표하여 공유한다
- 견적이 확실해지기 전까지 관리자는 자신의 원칙을 고수해야 한다

### Regenerative Schedule Disaster

Brooks’s Law

<aside>
💡 **Adding manpower to a late software project makes it later**

</aside>

- 최대 인력의 수는 독립적인 하부 작업 단위에 달려 있다
- 그러므로 사람 숫자는 되도록 줄이고 일정은 최대한 늘려 잡는 원칙에 근거하여야 한다